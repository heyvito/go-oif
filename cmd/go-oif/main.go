package main

import (
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"runtime"
	"strings"
	"sync"

	"github.com/heyvito/pine"
	"github.com/urfave/cli/v2"
	"golang.org/x/mod/modfile"

	"github.com/heyvito/go-oif/formatter"
)

func main() {
	logger := pine.NewWriter("oif")
	projectName := ""
	var projNameError error
	if _, err := os.Stat("./go.mod"); err == nil {
		data, err := ioutil.ReadFile("./go.mod")
		if err != nil {
			projNameError = err
		} else {
			file, err := modfile.Parse("go.mod", data, nil)
			if err != nil {
				projNameError = err
			} else {
				projectName = file.Module.Mod.Path
			}
		}
	}

	app := cli.NewApp()
	app.Name = "Opinionated Imports Formatter"
	app.Usage = "Formats imports grouping by source"
	app.Authors = []*cli.Author{
		{Name: "Vito Sartori", Email: "vito@hash.com.br"},
	}
	app.Flags = []cli.Flag{
		&cli.StringFlag{
			Name:        "project-name",
			Aliases:     []string{"n"},
			Usage:       "Indicates the base project name to sort imports. By default, oif detects the project name using data from your go.mod",
			Value:       projectName,
			DefaultText: projectName,
		},
	}

	app.Action = func(context *cli.Context) error {
		switch {
		case projectName == "" && projNameError != nil:
			logger.Error("Could not read project name from go.mod: %s", projNameError)
			logger.Error("Either use --project-name, or fix your go.mod")
			os.Exit(1)
		case projectName == "":
			logger.Error("Could not determine project name. Please set it using --project-name, or use go mod")
			os.Exit(1)
		}

		args := context.Args()
		if !args.Present() {
			logger.Error("Either provide a list of files to be processed or ./...")
			os.Exit(1)
		}

		var files []string
		if args.Get(0) == "./..." {
			// Recur everything from cwd onwards
			cwd, err := os.Getwd()
			if err != nil {
				logger.Error("Could not detect cwd: %s", err)
				os.Exit(1)
			}
			err = filepath.Walk(cwd, func(path string, info os.FileInfo, err error) error {
				if err == nil && filepath.Ext(info.Name()) == ".go" && !info.IsDir() {
					files = append(files, path)
				}
				return nil
			})
			if err != nil {
				logger.Error("Error listing files: %s", err)
				os.Exit(1)
			}
		} else {
			rawFiles := args.Slice()
			files = make([]string, len(rawFiles))
			var err error
			for i, p := range rawFiles {
				if files[i], err = filepath.Abs(p); err != nil {
					logger.Error("Error processing file %s: %s", p, err)
					os.Exit(1)
				}
			}
		}

		processFiles(files, projectName)
		return nil
	}

	if err := app.Run(os.Args); err != nil {
		log.Fatal(err)
	}
}

func processFiles(paths []string, projName string) {
	maxCPUs := runtime.NumCPU()
	input := make(chan string, 1000)
	toProcess := sync.WaitGroup{}
	toProcess.Add(len(paths))
	for i := 0; i < maxCPUs; i++ {
		go process(input, &toProcess, projName)
	}
	for _, p := range paths {
		input <- p
	}
	toProcess.Wait()
	close(input)
}

var autoGeneratedPattern = regexp.MustCompile(`^// Code generated .* DO NOT EDIT\.$`)

func process(f <-chan string, wd *sync.WaitGroup, projName string) {
consumer:
	for path := range f {
		stat, err := os.Stat(path)
		if err != nil {
			panic(err)
		}
		file, err := ioutil.ReadFile(path)
		for _, l := range strings.Split(string(file), "\n") {
			if autoGeneratedPattern.MatchString(l) {
				// File is auto generated. Do not edit.
				wd.Done()
				continue consumer
			}
		}

		if err != nil {
			panic(err)
		}
		file = []byte(formatter.FormatImports(projName, string(file)))
		err = ioutil.WriteFile(path, file, stat.Mode())
		if err != nil {
			panic(err)
		}
		wd.Done()
	}
}
